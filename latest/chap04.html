<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Case study: interface design · Think Julia</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Think Julia</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="chap00.html">Preface</a></li><li><a class="toctext" href="chap01.html">The way of the program</a></li><li><a class="toctext" href="chap02.html">Variables, expressions and statements</a></li><li><a class="toctext" href="chap03.html">Functions</a></li><li class="current"><a class="toctext" href="chap04.html">Case study: interface design</a><ul class="internal"><li><a class="toctext" href="#The-Luxor-module-1">The Luxor module</a></li><li><a class="toctext" href="#Simple-repetition-1">Simple repetition</a></li><li><a class="toctext" href="#Exercises-1">Exercises</a></li><li><a class="toctext" href="#Encapsulation-1">Encapsulation</a></li><li><a class="toctext" href="#Generalization-1">Generalization</a></li><li><a class="toctext" href="#Interface-design-1">Interface design</a></li><li><a class="toctext" href="#Refactoring-1">Refactoring</a></li><li><a class="toctext" href="#A-development-plan-1">A development plan</a></li><li><a class="toctext" href="#Docstring-1">Docstring</a></li><li><a class="toctext" href="#Debugging-1">Debugging</a></li><li><a class="toctext" href="#Glossary-1">Glossary</a></li><li><a class="toctext" href="#Exercises-2">Exercises</a></li></ul></li><li><a class="toctext" href="chap05.html">Conditionals and recursion</a></li><li><a class="toctext" href="chap06.html">Fruitful functions</a></li><li><a class="toctext" href="chap07.html">Iteration</a></li><li><a class="toctext" href="chap08.html">Strings</a></li><li><a class="toctext" href="chap09.html">Case study: word play</a></li><li><a class="toctext" href="chap10.html">Arrays</a></li><li><a class="toctext" href="chap11.html">Dictionaries</a></li><li><a class="toctext" href="chap12.html">Tuples</a></li><li><a class="toctext" href="chap13.html">Case study: data structure selection</a></li><li><a class="toctext" href="chap14.html">Files</a></li><li><a class="toctext" href="chap15.html">Structs and objects</a></li><li><a class="toctext" href="chap16.html">Structs and functions</a></li><li><a class="toctext" href="chap17.html">Multiple dispatch</a></li><li><a class="toctext" href="chap18.html">Subtyping</a></li><li><a class="toctext" href="chap19.html">The goodies</a></li><li><a class="toctext" href="chap20.html">Debugging</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="chap04.html">Case study: interface design</a></li></ul><a class="edit-page" href="https://github.com/BenLauwens/ThinkJulia.jl/blob/master/docs/src/chap04.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Case study: interface design</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Case-study:-interface-design-1" href="#Case-study:-interface-design-1">Case study: interface design</a></h1><p>This chapter presents a case study that demonstrates a process for designing functions that work together.</p><p>It introduces the <code>ThinkJulia</code> module, which allows you to create images using turtle graphics based on the <code>Luxor</code> package.</p><p>The examples in this chapter can be executed in a graphical notebook on JuliaBox, which combines code, formatted text, math, and multimedia in a single document.</p><h2><a class="nav-anchor" id="The-Luxor-module-1" href="#The-Luxor-module-1">The Luxor module</a></h2><p>A <strong>module</strong> is a file that contains a collection of related functions. Modules can be installed in the REPL by entering the Pkg REPL-mode using the key <code>]</code>.</p><pre><code class="language-julia-repl">(v0.7) pkg&gt; add ThinkJulia</code></pre><p>This can take some time.</p><p>Before we can use the functions in a module, we have to import it with an <code>using</code> statement:</p><pre><code class="language-julia-repl">julia&gt; using ThinkJulia

julia&gt; 🐢 = Turtle()
Luxor.Turtle(0.0, 0.0, true, 0.0, (0.0, 0.0, 0.0))</code></pre><p>The <code>ThinkJulia</code> module provides a function called <code>Turtle</code> that creates a <code>Luxor.Turtle</code> object, which we assign to a variable named <code>🐢</code> (<code>\:turtle: TAB</code>).</p><p>Once you create a turtle, you can call a function to move it around a drawing. For example, to move the turtle forward:</p><pre><code class="language-julia">@svg begin
    forward(🐢, 100)
end</code></pre><figure>
  <img src="fig41.svg" alt="Moving the turtle forward.">
  <figcaption>Figure 4.1. Moving the turtle forward.</figcaption>
</figure><p>The <code>@svg</code> keyword starts a macro that draws a svg picture. Macros are an important but advanced feature of Julia.</p><p>The arguments of <code>forward</code> are the turtle and a distance in pixels, so the actual size depends on your display.</p><p>Another function you can call with a turtle as argument is <code>turn</code> for turning. The second argument for <code>turn</code> is an angle in degrees.</p><p>Also, each turtle is holding a pen, which is either down or up; if the pen is down, the turtle leaves a trail when it moves. Figure 1 shows the trail left behind by the turtle. The functions <code>penup</code> and <code>pendown</code> stand for “pen up” and “pen down”.</p><p>To draw a right angle, modify the macro:</p><pre><code class="language-julia">🐢 = Turtle()
@svg begin
    forward(🐢, 100)
    turn(🐢, -90)
    forward(🐢, 100)
end</code></pre><p>Now modify the macro to draw a square. Don’t go on until you’ve got it working!</p><h2><a class="nav-anchor" id="Simple-repetition-1" href="#Simple-repetition-1">Simple repetition</a></h2><p>Chances are you wrote something like this:</p><pre><code class="language-julia">🐢 = Turtle()
@svg begin
    forward(🐢, 100)
    turn(🐢, -90)
    forward(🐢, 100)
    turn(🐢, -90)
    forward(🐢, 100)
    turn(🐢, -90)
    forward(🐢, 100)
end</code></pre><p>We can do the same thing more concisely with a <code>for</code> statement:</p><pre><code class="language-julia-repl">julia&gt; for i in 1:4
          println(&quot;Hello!&quot;)
       end
Hello!
Hello!
Hello!
Hello!</code></pre><p>This is the simplest use of the <code>for</code> statement; we will see more later. But that should be enough to let you rewrite your square-drawing program. Don’t go on until you do.</p><p>Here is a <code>for</code> statement that draws a square:</p><pre><code class="language-julia">🐢 = Turtle()
@svg begin
    for i in 1:4
        forward(🐢, 100)
        turn(🐢, -90)
    end
end</code></pre><p>The syntax of a <code>for</code> statement is similar to a function definition. It has a header and a body that ends with the keyword <code>end</code>. The body can contain any number of statements.</p><p>A <code>for</code> statement is also called a <strong>loop</strong> because the flow of execution runs through the body and then loops back to the top. In this case, it runs the body four times.</p><p>This version is actually a little different from the previous square-drawing code because it makes another turn after drawing the last side of the square. The extra turn takes more time, but it simplifies the code if we do the same thing every time through the loop. This version also has the effect of leaving the turtle back in the starting position, facing in the starting direction.</p><h2><a class="nav-anchor" id="Exercises-1" href="#Exercises-1">Exercises</a></h2><p>The following is a series of exercises using turtles. They are meant to be fun, but they have a point, too. While you are working on them, think about what the point is.</p><p>The following sections have solutions to the exercises, so don’t look until you have finished (or at least tried).</p><ol><li><p>Write a function called <code>square</code> that takes a parameter named <code>t</code>, which is a turtle. It should use the turtle to draw a square.</p></li><li><p>Write a function call that passes <code>t</code> as an argument to <code>square</code>, and then run the macro again.</p></li><li><p>Add another parameter, named <code>len</code>, to square. Modify the body so length of the sides is <code>len</code>, and then modify the function call to provide a second argument. Run the macro again. Test with a range of values for <code>len</code>.</p></li><li><p>Make a copy of <code>square</code> and change the name to <code>polygon</code>. Add another parameter named <code>n</code> and modify the body so it draws an <span>$n$</span>-sided regular polygon. Hint: The exterior angles of an <span>$n$</span>-sided regular polygon are <span>$\frac{360}{n}$</span> degrees.</p></li><li><p>Write a function called <code>circle</code> that takes a turtle, <code>t</code>, and radius, <code>r</code>, as parameters and that draws an approximate circle by calling <code>polygon</code> with an appropriate length and number of sides. Test your function with a range of values of <code>r</code>. Hint: figure out the circumference of the circle and make sure that <code>len * n == circumference</code>.</p></li><li><p>Make a more general version of <code>circle</code> called <code>arc</code> that takes an additional parameter <code>angle</code>, which determines what fraction of a circle to draw. <code>angle</code> is in units of degrees, so when <code>angle=360</code>, <code>arc</code> should draw a complete circle.</p></li></ol><h2><a class="nav-anchor" id="Encapsulation-1" href="#Encapsulation-1">Encapsulation</a></h2><p>The first exercise asks you to put your square-drawing code into a function definition and then call the function, passing the turtle as a parameter. Here is a solution:</p><pre><code class="language-julia">function square(t)
    for i in 1:4
        forward(t, 100)
        turn(t, -90)
    end
end
🐢 = Turtle()
@svg begin
    square(🐢)
end</code></pre><p>The innermost statements, <code>forward</code> and <code>turn</code> are indented twice to show that they are inside the <code>for</code> loop, which is inside the function definition.</p><p>Inside the function, <code>t</code> refers to the same turtle <code>🐢</code>, so <code>turn(t, -90)</code> has the same effect as <code>turn(🐢, -90)</code>. In that case, why not call the parameter <code>🐢</code>? The idea is that <code>t</code> can be any turtle, not just <code>🐢</code>, so you could create a second turtle and pass it as an argument to <code>square</code>:</p><pre><code class="language-julia">🐫 = Turtle()
@svg begin
    square(🐫)
end</code></pre><p>Wrapping a piece of code up in a function is called <strong>encapsulation</strong>. One of the benefits of encapsulation is that it attaches a name to the code, which serves as a kind of documentation. Another advantage is that if you re-use the code, it is more concise to call a function twice than to copy and paste the body!</p><h2><a class="nav-anchor" id="Generalization-1" href="#Generalization-1">Generalization</a></h2><p>The next step is to add a <code>len</code> parameter to <code>square</code>. Here is a solution:</p><pre><code class="language-julia">function square(t, len)
    for i in 1:4
        forward(t, len)
        turn(t, -90)
    end
end
🐢 = Turtle()
@svg begin
    square(🐢, 100)
end</code></pre><p>Adding a parameter to a function is called <strong>generalization</strong> because it makes the function more general: in the previous version, the square is always the same size; in this version it can be any size.</p><p>The next step is also a generalization. Instead of drawing squares, <code>polygon</code> draws regular polygons with any number of sides. Here is a solution:</p><pre><code class="language-julia">function polygon(t, n, len)
    angle = 360 / n
    for i in 1:n
        forward(t, len)
        turn(t, -angle)
    end
end
🐢 = Turtle()
@svg begin
    polygon(🐢, 7, 70)
end</code></pre><p>This example draws a 7-sided polygon with side length 70.</p><h2><a class="nav-anchor" id="Interface-design-1" href="#Interface-design-1">Interface design</a></h2><p>The next step is to write <code>circle</code>, which takes a radius, <code>r</code>, as a parameter. Here is a simple solution that uses <code>polygon</code> to draw a 50-sided polygon:</p><pre><code class="language-julia">function circle(t, r)
    circumference = 2 * π * r
    n = 50
    len = circumference / n
    polygon(t, n, len)
end</code></pre><p>The first line computes the circumference of a circle with radius <span>$r$</span> using the formula <span>$2 π r$</span>. <code>n</code> is the number of line segments in our approximation of a circle, so <code>len</code> is the length of each segment. Thus, <code>polygon</code> draws a 50-sided polygon that approximates a circle with radius <code>r</code>.</p><p>One limitation of this solution is that <code>n</code> is a constant, which means that for very big circles, the line segments are too long, and for small circles, we waste time drawing very small segments. One solution would be to generalize the function by taking <code>n</code> as a parameter. This would give the user (whoever calls circle) more control, but the interface would be less clean.</p><p>The <strong>interface</strong> of a function is a summary of how it is used: what are the parameters? What does the function do? And what is the return value? An interface is “clean” if it allows the caller to do what they want without dealing with unnecessary details.</p><p>In this example, <code>r</code> belongs in the interface because it specifies the circle to be drawn. <code>n</code> is less appropriate because it pertains to the details of how the circle should be rendered.</p><p>Rather than clutter up the interface, it is better to choose an appropriate value of <code>n</code> depending on <code>circumference</code>:</p><pre><code class="language-julia">function circle(t, r)
    circumference = 2 * π * r
    n = trunc(circumference / 3) + 3
    len = circumference / n
    polygon(t, n, len)
end</code></pre><p>Now the number of segments is an integer near <code>circumference/3</code>, so the length of each segment is approximately 3, which is small enough that the circles look good, but big enough to be efficient, and acceptable for any size circle.</p><p>Adding 3 to <code>n</code> guarantees that the polygon has at least 3 sides.</p><h2><a class="nav-anchor" id="Refactoring-1" href="#Refactoring-1">Refactoring</a></h2><p>When I wrote <code>circle</code>, I was able to re-use <code>polygon</code> because a many-sided polygon is a good approximation of a circle. But <code>arc</code> is not as cooperative; we can’t use <code>polygon</code> or <code>circle</code> to draw an arc.</p><p>One alternative is to start with a copy of <code>polygon</code> and transform it into <code>arc</code>. The result might look like this:</p><pre><code class="language-julia">function arc(t, r, angle)
    arc_len = 2 * π * r * angle / 360
    n = trunc(arc_len / 3) + 1
    step_len = arc_len / n
    step_angle = angle / n
    for i in 1:n
        forward(t, step_len)
        turn(t, -step_angle)
    end
end</code></pre><p>The second half of this function looks like <code>polygon</code>, but we can’t re-use <code>polygon</code> without changing the interface. We could generalize <code>polygon</code> to take an <code>angle</code> as a third argument, but then <code>polygon</code> would no longer be an appropriate name! Instead, let’s call the more general function <code>polyline</code>:</p><pre><code class="language-julia">function polyline(t, n, len, angle)
    for i in 1:n
        forward(t, len)
        turn(t, -angle)
    end
end</code></pre><p>Now we can rewrite <code>polygon</code> and <code>arc</code> to use <code>polyline</code>:</p><pre><code class="language-julia">function polygon(t, n, len)
    angle = 360 / n
    polyline(t, n, len, angle)
end

function arc(t, r, angle)
    arc_len = 2 * π * r * angle / 360
    n = trunc(arc_len / 3) + 1
    step_len = arc_len / n
    step_angle = angle / n
    polyline(t, n, step_len, step_angle)
end</code></pre><p>Finally, we can rewrite <code>circle</code> to use <code>arc</code>:</p><pre><code class="language-julia">function circle(t, r)
    arc(t, r, 360)
end</code></pre><p>This process—rearranging a program to improve interfaces and facilitate code re-use—is called <strong>refactoring</strong>. In this case, we noticed that there was similar code in <code>arc</code> and <code>polygon</code>, so we “factored it out” into <code>polyline</code>.</p><p>If we had planned ahead, we might have written <code>polyline</code> first and avoided refactoring, but often you don’t know enough at the beginning of a project to design all the interfaces. Once you start coding, you understand the problem better. Sometimes refactoring is a sign that you have learned something.</p><h2><a class="nav-anchor" id="A-development-plan-1" href="#A-development-plan-1">A development plan</a></h2><p>A <strong>development plan</strong> is a process for writing programs. The process we used in this case study is “encapsulation and generalization”. The steps of this process are:</p><ol><li><p>Start by writing a small program with no function definitions.</p></li><li><p>Once you get the program working, identify a coherent piece of it, encapsulate the piece in a function and give it a name.</p></li><li><p>Generalize the function by adding appropriate parameters.</p></li><li><p>Repeat steps 1–3 until you have a set of working functions. Copy and paste working code to avoid retyping (and re-debugging).</p></li><li><p>Look for opportunities to improve the program by refactoring. For example, if you have similar code in several places, consider factoring it into an appropriately general function.</p></li></ol><p>This process has some drawbacks—we will see alternatives later—but it can be useful if you don’t know ahead of time how to divide the program into functions. This approach lets you design as you go along.</p><h2><a class="nav-anchor" id="Docstring-1" href="#Docstring-1">Docstring</a></h2><p>A <strong>docstring</strong> is a string before a function that explains the interface (“doc” is short for “documentation”). Here is an example:</p><pre><code class="language-julia">&quot;&quot;&quot;
polyline(t, n, len, angle)

Draws n line segments with the given length and
angle (in degrees) between them.  t is a turtle.
&quot;&quot;&quot;
function polyline(t, n, len, angle)
    for i in 1:n
        forward(t, len)
        turn(t, -angle)
    end
end</code></pre><p>Documentation can be accessed in the REPL or in a notebook by typing ? followed by the name of a function or macro, and pressing <code>ENTER</code>:</p><pre><code class="language-julia">help?&gt; polyline
search:

  polyline(t, n, len, angle)

  Draws n line segments with the given length and angle (in degrees) between them. t is a turtle.</code></pre><p>By convention, all docstrings are triple-quoted strings, also known as multiline strings because the triple quotes allow the string to span more than one line.</p><p>It is terse, but it contains the essential information someone would need to use this function. It explains concisely what the function does (without getting into the details of how it does it). It explains what effect each parameter has on the behavior of the function and what type each parameter should be (if it is not obvious).</p><p>Writing this kind of documentation is an important part of interface design. A well-designed interface should be simple to explain; if you have a hard time explaining one of your functions, maybe the interface could be improved.</p><h2><a class="nav-anchor" id="Debugging-1" href="#Debugging-1">Debugging</a></h2><p>An interface is like a contract between a function and a caller. The caller agrees to provide certain parameters and the function agrees to do certain work.</p><p>For example, <code>polyline</code> requires four arguments: <code>t</code> has to be a turtle; <code>n</code> has to be an integer; <code>len</code> should be a positive number; and <code>angle</code> has to be a number, which is understood to be in degrees.</p><p>These requirements are called <strong>preconditions</strong> because they are supposed to be true before the function starts executing. Conversely, conditions at the end of the function are <strong>postconditions</strong>. Postconditions include the intended effect of the function (like drawing line segments) and any side effects (like moving the turtle or making other changes).</p><p>Preconditions are the responsibility of the caller. If the caller violates a (properly documented!) precondition and the function doesn’t work correctly, the bug is in the caller, not the function.</p><p>If the preconditions are satisfied and the postconditions are not, the bug is in the function. If your pre- and postconditions are clear, they can help with debugging.</p><h2><a class="nav-anchor" id="Glossary-1" href="#Glossary-1">Glossary</a></h2><p><em>module</em>: A file that contains a collection of related functions and other definitions.</p><p><em>using statement</em>: A statement that reads a module file and creates a module object.</p><p><em>loop</em>: A part of a program that can run repeatedly.</p><p><em>encapsulation</em>: The process of transforming a sequence of statements into a function definition.</p><p><em>generalization</em>: The process of replacing something unnecessarily specific (like a number) with something appropriately general (like a variable or parameter).</p><p><em>interface</em>: A description of how to use a function, including the name and descriptions of the arguments and return value.</p><p><em>refactoring</em>: The process of modifying a working program to improve function interfaces and other qualities of the code.</p><p><em>development plan</em>: A process for writing programs.</p><p><em>docstring</em>: A string that appears at the top of a function definition to document the function’s interface.</p><p><em>precondition</em>: A requirement that should be satisfied by the caller before a function starts.</p><p><em>postcondition</em>: A requirement that should be satisfied by the function before it ends.</p><h2><a class="nav-anchor" id="Exercises-2" href="#Exercises-2">Exercises</a></h2><h3><a class="nav-anchor" id="Exercise-4-1-1" href="#Exercise-4-1-1">Exercise 4-1</a></h3><p>Enter the code in this chapter in a notebook.</p><ol><li><p>Draw a stack diagram that shows the state of the program while executing <code>circle(🐢, radius)</code>. You can do the arithmetic by hand or add print statements to the code.</p></li><li><p>The version of <code>arc</code> in Section 4.7 is not very accurate because the linear approximation of the circle is always outside the true circle. As a result, the turtle ends up a few pixels away from the correct destination. My solution shows a way to reduce the effect of this error. Read the code and see if it makes sense to you. If you draw a diagram, you might see how it works.</p></li></ol><pre><code class="language-julia">&quot;&quot;&quot;
arc(t, r, angle)

Draws an arc with the given radius and angle:

    t: turtle
    r: radius
    angle: angle subtended by the arc, in degrees
&quot;&quot;&quot;
function arc(t, r, angle)
    arc_len = 2 * π * r * abs(angle) / 360
    n = trunc(arc_len / 4) + 3
    step_len = arc_len / n
    step_angle = angle / n

    # making a slight left turn before starting reduces
    # the error caused by the linear approximation of the arc
    turn(t, step_angle/2)
    polyline(t, n, step_len, step_angle)
    turn(t, -step_angle/2)
end</code></pre><h3><a class="nav-anchor" id="Exercise-4-2-1" href="#Exercise-4-2-1">Exercise 4-2</a></h3><p>Write an appropriately general set of functions that can draw flowers as in Figure 4.2.</p><figure>
  <img src="fig42.svg" alt="Turtle flowers.">
  <figcaption>Figure 4.2. Turtle flowers.</figcaption>
</figure><h3><a class="nav-anchor" id="Exercise-4-3-1" href="#Exercise-4-3-1">Exercise 4-3</a></h3><p>Write an appropriately general set of functions that can draw shapes as in Figure 4.3.</p><figure>
  <img src="fig43.svg" alt="Turtle pies.">
  <figcaption>Figure 4.3. Turtle pies.</figcaption>
</figure><h3><a class="nav-anchor" id="Exercise-4-4-1" href="#Exercise-4-4-1">Exercise 4-4</a></h3><p>The letters of the alphabet can be constructed from a moderate number of basic elements, like vertical and horizontal lines and a few curves. Design an alphabet that can be drawn with a minimal number of basic elements and then write functions that draw the letters.</p><p>You should write one function for each letter, with names <code>draw_a</code>, <code>draw_b</code>, etc., and put your functions in a file named <code>letters.jl</code>.</p><h3><a class="nav-anchor" id="Exercise-4-5-1" href="#Exercise-4-5-1">Exercise 4-5</a></h3><p>Read about spirals at <a href="http://en.wikipedia.org/wiki/Spiral">http://en.wikipedia.org/wiki/Spiral</a>; then write a program that draws an Archimedian spiral as in Figure 4.4.</p><figure>
  <img src="fig44.svg" alt="Archimedian spiral.">
  <figcaption>Figure 4.4. Archimedian spiral.</figcaption>
</figure><footer><hr/><a class="previous" href="chap03.html"><span class="direction">Previous</span><span class="title">Functions</span></a><a class="next" href="chap05.html"><span class="direction">Next</span><span class="title">Conditionals and recursion</span></a></footer></article></body></html>
