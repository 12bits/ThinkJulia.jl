<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Structs and objects · Think Julia</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Think Julia</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="copyright.html">-</a></li><li><a class="toctext" href="preface.html">Preface</a></li><li><a class="toctext" href="chap01.html">The way of the program</a></li><li><a class="toctext" href="chap02.html">Variables, expressions and statements</a></li><li><a class="toctext" href="chap03.html">Functions</a></li><li><a class="toctext" href="chap04.html">Case study: interface design</a></li><li><a class="toctext" href="chap05.html">Conditionals and recursion</a></li><li><a class="toctext" href="chap06.html">Fruitful functions</a></li><li><a class="toctext" href="chap07.html">Iteration</a></li><li><a class="toctext" href="chap08.html">Strings</a></li><li><a class="toctext" href="chap09.html">Case study: word play</a></li><li><a class="toctext" href="chap10.html">Arrays</a></li><li><a class="toctext" href="chap11.html">Dictionaries</a></li><li><a class="toctext" href="chap12.html">Tuples</a></li><li><a class="toctext" href="chap13.html">Case study: data structure selection</a></li><li><a class="toctext" href="chap14.html">Files</a></li><li class="current"><a class="toctext" href="chap15.html">Structs and objects</a><ul class="internal"><li><a class="toctext" href="#Composite-types-1">Composite types</a></li><li><a class="toctext" href="#Structs-are-immutable-1">Structs are immutable</a></li><li><a class="toctext" href="#Mutable-structs-1">Mutable structs</a></li><li><a class="toctext" href="#Rectangles-1">Rectangles</a></li><li><a class="toctext" href="#Instances-as-return-values-1">Instances as return values</a></li><li><a class="toctext" href="#Instances-as-arguments-1">Instances as arguments</a></li><li><a class="toctext" href="#Copying-1">Copying</a></li><li><a class="toctext" href="#Debugging-1">Debugging</a></li><li><a class="toctext" href="#Glossary-1">Glossary</a></li><li><a class="toctext" href="#Exercises-1">Exercises</a></li></ul></li><li><a class="toctext" href="chap16.html">Structs and functions</a></li><li><a class="toctext" href="chap17.html">Multiple dispatch</a></li><li><a class="toctext" href="chap18.html">Subtyping</a></li><li><a class="toctext" href="chap19.html">The goodies</a></li><li><a class="toctext" href="chap20.html">Debugging</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="chap15.html">Structs and objects</a></li></ul><a class="edit-page" href="https://github.com/BenLauwens/ThinkJulia.jl/blob/master/docs/src/chap15.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Structs and objects</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Structs-and-objects-1" href="#Structs-and-objects-1">Structs and objects</a></h1><p>At this point you know how to use functions to organize code and built-in types to organize data. The next step is to learn how to build your own types to organize both code and data. This is a big topic; it will take a few chapters to get there.</p><h2><a class="nav-anchor" id="Composite-types-1" href="#Composite-types-1">Composite types</a></h2><p>We have used many of Julia’s built-in types; now we are going to define a new type. As an example, we will create a type called <code>Point</code> that represents a point in two-dimensional space.</p><p>In mathematical notation, points are often written in parentheses with a comma separating the coordinates. For example, <span>$(0,0)$</span> represents the origin, and <span>$(x,y)$</span> represents the point <span>$x$</span> units to the right and <span>$y$</span> units up from the origin.</p><p>There are several ways we might represent points in Julia:</p><ul><li><p>We could store the coordinates separately in two variables, <code>x</code> and <code>y</code>.</p></li><li><p>We could store the coordinates as elements in a list or tuple.</p></li><li><p>We could create a new type to represent points as objects.</p></li></ul><p>Creating a new type is more complicated than the other options, but it has advantages that will be apparent soon.</p><p>A programmer-defined <strong>composite type</strong> is also called a <strong>struct</strong>. The <code>struct</code> definition for a point looks like this:</p><pre><code class="language-julia">struct Point
    x
    y
end</code></pre><p>The header indicates that the new struct is called <code>Point</code>. The body defines the <strong>attributes</strong> or <strong>fields</strong> of the struct. The <code>Point</code> struct has two fields: <code>x</code> and <code>y</code>. As a noun, “AT-trib-ute” is pronounced with emphasis on the first syllable, as opposed to “a-TRIB-ute”, which is a verb.</p><p>Defining a type named Point creates a datatype object:</p><pre><code class="language-julia-repl">julia&gt; typeof(Point)
DataType
julia&gt; Point
ThinkJulia.Point</code></pre><p>Because <code>Point</code> is defined in the module <code>ThinkJulia</code>, its “full name” is <code>ThinkJulia.Point</code>.</p><p>A struct is like a factory for creating objects. To create a point, you call <code>Point</code> as if it were a function having as arguments the values of the fields. When <code>Point</code> is used as a function, it is called a <strong>constructor</strong>.</p><pre><code class="language-julia-repl">julia&gt; p = Point(3.0, 4.0)
ThinkJulia.Point(3.0, 4.0)</code></pre><p>The return value is a reference to a point object, which we assign to <code>p</code>.</p><p>Creating a new object is called <strong>instantiation</strong>, and the object is an <strong>instance</strong> of the type.</p><p>When you print an instance, Julia tells you what type it belongs to and what the values of the atributes are.</p><p>Every object is an instance of some type, so “object” and “instance” are interchangeable. But in this chapter I use “instance” to indicate that I am talking about a programmer-defined type.</p><p>A state diagram that shows an object and its fields is called an <em>object diagram</em>; see Figure 15.1.</p><figure>
  <img src="fig151.svg" alt="Object diagram.">
  <figcaption>Figure 15.1. Object diagram.</figcaption>
</figure><h2><a class="nav-anchor" id="Structs-are-immutable-1" href="#Structs-are-immutable-1">Structs are immutable</a></h2><p>You can get the values of the fields using <code>.</code> notation:</p><pre><code class="language-julia-repl">julia&gt; x = p.x
3.0
julia&gt; p.y
4.0</code></pre><p>The expression <code>p.x</code> means, “Go to the object <code>p</code> refers to and get the value of <code>x</code>.” In the example, we assign that value to a variable named <code>x</code>. There is no conflict between the variable <code>x</code> and the field <code>x</code>.</p><p>You can use dot notation as part of any expression. For example:</p><pre><code class="language-julia-repl">julia&gt; distance = sqrt(p.x^2 + p.y^2)
5.0</code></pre><p>Structs are however by default immutable, after construction the fields can not change value:</p><pre><code class="language-julia-repl">julia&gt; p.y = 1.0
ERROR: type Point is immutable</code></pre><p>This may seem odd at first, but it has several advantages:</p><ul><li><p>It can be more efficient.</p></li><li><p>It is not possible to violate the invariants provided by the type&#39;s constructors (see later).</p></li><li><p>Code using immutable objects can be easier to reason about.</p></li></ul><h2><a class="nav-anchor" id="Mutable-structs-1" href="#Mutable-structs-1">Mutable structs</a></h2><p>Where required, mutable composite types can be declared with the keyword <code>mutable struct</code>. Here is the definition of a mutable point:</p><pre><code class="language-julia">mutable struct MPoint
    x
    y
end</code></pre><p>You can assign values to an instance of a mutable struct using dot notation:</p><pre><code class="language-julia-repl">julia&gt; blank = MPoint(0.0, 0.0)
ThinkJulia.MPoint(0.0, 0.0)
julia&gt; blank.x = 3.0
3.0
julia&gt; blank.y = 4.0
4.0</code></pre><p>You can pass an instance as an argument in the usual way. For example:</p><pre><code class="language-julia">function printpoint(p)
    println(&quot;($(p.x), $(p.y))&quot;)
end</code></pre><p><code>printpoint</code> takes a point as an argument and displays it in mathematical notation. To invoke it, you can pass <code>p</code> as an argument:</p><pre><code class="language-julia-repl">julia&gt; printpoint(blank)
(3.0, 4.0)</code></pre><p>As an exercise, write a function called <code>distancebetweenpoints</code> that takes two points as arguments and returns the distance between them.</p><h2><a class="nav-anchor" id="Rectangles-1" href="#Rectangles-1">Rectangles</a></h2><p>Sometimes it is obvious what the fields of an object should be, but other times you have to make decisions. For example, imagine you are designing a type to represent rectangles. What fields would you use to specify the location and size of a rectangle? You can ignore angle; to keep things simple, assume that the rectangle is either vertical or horizontal.</p><p>There are at least two possibilities:</p><ul><li><p>You could specify one corner of the rectangle (or the center), the width, and the height.</p></li><li><p>You could specify two opposing corners.</p></li></ul><p>At this point it is hard to say whether either is better than the other, so we’ll implement the first one, just as an example.</p><pre><code class="language-julia">&quot;&quot;&quot;
Represents a rectangle.

fields: width, height, corner.
&quot;&quot;&quot;
struct Rectangle
    width
    height
    corner
end</code></pre><p>The docstring lists the fields: width and height are numbers; corner is a point object that specifies the lower-left corner.</p><p>To represent a rectangle, you have to instantiate a rectangle object:</p><pre><code class="language-julia-repl">julia&gt; origin = MPoint(0.0, 0.0)
ThinkJulia.MPoint(0.0, 0.0)
julia&gt; box = Rectangle(100.0, 200.0, origin)
ThinkJulia.Rectangle(100.0, 200.0, ThinkJulia.MPoint(0.0, 0.0))</code></pre><p>Figure 15.2 shows the state of this object. An object that is a field of another object is <strong>embedded</strong>. Because the <code>corner</code> attribute refers to a mutable object, the latter is drawn outside the rectangle object.</p><figure>
  <img src="fig152.svg" alt="Object diagram.">
  <figcaption>Figure 15.2. Object diagram.</figcaption>
</figure><h2><a class="nav-anchor" id="Instances-as-return-values-1" href="#Instances-as-return-values-1">Instances as return values</a></h2><p>Functions can return instances. For example, <code>findcenter</code> takes a rectangle as an argument and returns a point that contains the coordinates of the center of the rectangle:</p><pre><code class="language-julia">function findcenter(rect)
    Point(rect.corner.x, rect.corner.y)
end</code></pre><p>The expression <code>rect.corner.x</code> means, “Go to the object <code>rect</code> refers to and select the field named <code>corner</code>; then go to that object and select the field named <code>x</code>.”</p><p>Here is an example that passes <code>box</code> as an argument and assigns the resulting point to <code>center</code>:</p><pre><code class="language-julia-repl">julia&gt; center = findcenter(box)
ThinkJulia.Point(0.0, 0.0)</code></pre><h2><a class="nav-anchor" id="Instances-as-arguments-1" href="#Instances-as-arguments-1">Instances as arguments</a></h2><p>If a mutable struct object is passed to a function as an argument, the function can modify the fields of the object. For example, <code>movepoint</code> takes a mutable point object and two numbers, <code>dx</code> and <code>dy</code>, and adds the numbers to respectively the <code>x</code> and the <code>y</code> attribute of the point:</p><pre><code class="language-julia">function movepoint!(p, dx, dy)
    p.x += dx
    p.y += dy
    nothing
end</code></pre><p>Here is an example that demonstrates the effect:</p><pre><code class="language-julia-repl">julia&gt; origin = MPoint(0.0,0.0)
ThinkJulia.MPoint(0.0, 0.0)
julia&gt; movepoint!(origin, 1.0, 2.0)

julia&gt; origin
ThinkJulia.MPoint(1.0, 2.0)</code></pre><p>Inside the function, <code>p</code> is an alias for <code>origin</code>, so when the function modifies <code>p</code>, <code>origin</code> changes.</p><p>Passing an immutable point object to <code>movepoint!</code> causes an error:</p><pre><code class="language-julia-repl">julia&gt; movepoint!(p, 1.0, 2.0)
ERROR: type is immutable</code></pre><p>You can however modify the value of a mutable attribute of an immutable object. For example, <code>moverectangle!</code> has as arguments a rectangle object and two numbers, <code>dx</code> and <code>dy</code>, and uses <code>movepoint!</code> to move the corner of the rectangle:</p><pre><code class="language-julia">function moverectangle!(rect, dx, dy)
  movepoint!(rect.corner, dx, dy)
end</code></pre><p>Now <code>p</code> in <code>movepoint!</code> is an alias for <code>rect.corner</code>, so when <code>p</code> is modified, <code>rect.corner</code> changes also:</p><pre><code class="language-julia-repl">julia&gt; box
ThinkJulia.Rectangle(100.0, 200.0, ThinkJulia.MPoint(0.0, 0.0))
julia&gt; moverectangle!(box, 1.0, 2.0)

julia&gt; box
ThinkJulia.Rectangle(100.0, 200.0, ThinkJulia.MPoint(1.0, 2.0))</code></pre><p>Attention you cannot reassign a mutable attribute of an immutable object:</p><pre><code class="language-julia-repl">julia&gt; box.corner = MPoint(1.0, 2.0)
ERROR: type Rectangle is immutable</code></pre><h2><a class="nav-anchor" id="Copying-1" href="#Copying-1">Copying</a></h2><p>Aliasing can make a program difficult to read because changes in one place might have unexpected effects in another place. It is hard to keep track of all the variables that might refer to a given object.</p><p>Copying an object is often an alternative to aliasing. Julia provides a function called <code>deepcopy</code> that can duplicate any object:</p><pre><code class="language-julia-repl">julia&gt; p1 = MPoint(3.0, 4.0)
ThinkJulia.MPoint(3.0, 4.0)
julia&gt; p2 = deepcopy(p1)
ThinkJulia.MPoint(3.0, 4.0)
julia&gt; p1 ≡ p2
false
julia&gt; p1 == p2
false</code></pre><p>The <code>≡</code> operator indicates that <code>p1</code> and <code>p2</code> are not the same object, which is what we expected. But you might have expected <code>==</code> to yield <code>true</code> because these points contain the same data. In that case, you will be disappointed to learn that for mutable objects, the default behavior of the <code>==</code> operator is the same as the <code>===</code> operator; it checks object identity, not object equivalence. That’s because for mutable composite types, Julia doesn’t know what should be considered equivalent. At least, not yet.</p><p>As an exercise, create a <code>Point</code> instance, make a copy of it and check the equivalence and the egality of both. The result can surprise you but it explains why aliasing is a non issue for an immutable object.</p><h2><a class="nav-anchor" id="Debugging-1" href="#Debugging-1">Debugging</a></h2><p>When you start working with objects, you are likely to encounter some new exceptions. If you try to access a field that doesn’t exist, you get:</p><pre><code class="language-julia-repl">julia&gt; p = Point(3.0, 4.0)
ThinkJulia.Point(3.0, 4.0)
julia&gt; p.z = 1.0
ERROR: type Point is immutable</code></pre><p>If you are not sure what type an object is, you can ask:</p><pre><code class="language-julia-repl">julia&gt; typeof(p)
ThinkJulia.Point</code></pre><p>You can also use isinstance to check whether an object is an instance of a type:</p><pre><code class="language-julia-repl">julia&gt; p isa Point
true</code></pre><p>If you are not sure whether an object has a particular attribute, you can use the built-in function <code>fieldnames</code>:</p><pre><code class="language-julia-repl">julia&gt; fieldnames(Point)
(:x, :y)</code></pre><p>or the function <code>isdefined</code>:</p><pre><code class="language-julia-repl">julia&gt; isdefined(p, :x)
true
julia&gt; isdefined(p, :z)
false</code></pre><p>The first argument can be any object; the second argument is a symbol, <code>:</code> followed by the name of the field.</p><p>You can also use a <code>try</code> statement to see if the object has the fields you need:</p><pre><code class="language-julia">try
    x = 1.0
catch exc
    x = 0.0
end</code></pre><h2><a class="nav-anchor" id="Glossary-1" href="#Glossary-1">Glossary</a></h2><p><em>struct</em>: A composite type. A struct definition creates a new struct object.</p><p><em>struct object</em>: An object that contains information about a composite type. The struct object can be used to create instances of the type.</p><p><em>instance</em>: An object that belongs to a type.</p><p><em>instantiate</em>: To create a new object.</p><p><em>attribute</em> or <em>field</em>: One of the named values associated with an object.</p><p><em>embedded object</em>: An object that is stored as a field of another object.</p><p><em>deep copy</em>: To copy the contents of an object as well as any embedded objects, and any objects embedded in them, and so on; implemented by the <code>deepcopy</code> function.</p><p><em>object diagram</em>: A diagram that shows objects, their fields, and the values of the fields.</p><h2><a class="nav-anchor" id="Exercises-1" href="#Exercises-1">Exercises</a></h2><h3><a class="nav-anchor" id="Exercise-15-1-1" href="#Exercise-15-1-1">Exercise 15-1</a></h3><ol><li><p>Write a definition for a type named <code>Circle</code> with fields <code>center</code> and <code>radius</code>, where <code>center</code> is a point object and <code>radius</code> is a number.</p></li><li><p>Instantiate a circle object that represents a circle with its center at <span>$(150, 100)$</span> and radius <span>$75$</span>.</p></li><li><p>Write a function named <code>pointincircle</code> that takes a circle object and a point object and returns <code>true</code> if the point lies in or on the boundary of the circle.</p></li><li><p>Write a function named <code>rectincircle</code> that takes a circle object and a rectangle object and returns <code>true</code> if the rectangle lies entirely in or on the boundary of the circle.</p></li><li><p>Write a function named <code>rectcircleoverlap</code> that takes a circle object and a rectangle object and returns <code>true</code> if any of the corners of the rectangle fall inside the circle. Or as a more challenging version, return <code>true</code> if any part of the rectangle falls inside the circle.</p></li></ol><h3><a class="nav-anchor" id="Exercise-15-2-1" href="#Exercise-15-2-1">Exercise 15-2</a></h3><ol><li><p>Write a function called <code>drawrect</code> that takes a turtle object and a rectangle object and uses the turtle to draw the rectangle. See Chapter 4 for examples using turtle objects.</p></li><li><p>Write a function called <code>drawcircle</code> that takes a turtle object and a circle object and draws the circle.</p></li></ol><footer><hr/><a class="previous" href="chap14.html"><span class="direction">Previous</span><span class="title">Files</span></a><a class="next" href="chap16.html"><span class="direction">Next</span><span class="title">Structs and functions</span></a></footer></article></body></html>
