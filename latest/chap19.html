<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The goodies · Think Julia</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Think Julia</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="copyright.html">Copyright</a></li><li><a class="toctext" href="preface.html">Preface</a></li><li><a class="toctext" href="chap01.html">The way of the program</a></li><li><a class="toctext" href="chap02.html">Variables, expressions and statements</a></li><li><a class="toctext" href="chap03.html">Functions</a></li><li><a class="toctext" href="chap04.html">Case study: interface design</a></li><li><a class="toctext" href="chap05.html">Conditionals and recursion</a></li><li><a class="toctext" href="chap06.html">Fruitful functions</a></li><li><a class="toctext" href="chap07.html">Iteration</a></li><li><a class="toctext" href="chap08.html">Strings</a></li><li><a class="toctext" href="chap09.html">Case study: word play</a></li><li><a class="toctext" href="chap10.html">Arrays</a></li><li><a class="toctext" href="chap11.html">Dictionaries</a></li><li><a class="toctext" href="chap12.html">Tuples</a></li><li><a class="toctext" href="chap13.html">Case study: data structure selection</a></li><li><a class="toctext" href="chap14.html">Files</a></li><li><a class="toctext" href="chap15.html">Structs and objects</a></li><li><a class="toctext" href="chap16.html">Structs and functions</a></li><li><a class="toctext" href="chap17.html">Multiple dispatch</a></li><li><a class="toctext" href="chap18.html">Subtyping</a></li><li class="current"><a class="toctext" href="chap19.html">The goodies</a><ul class="internal"><li><a class="toctext" href="#Named-tuples-1">Named tuples</a></li><li><a class="toctext" href="#Keyword-arguments-1">Keyword arguments</a></li><li><a class="toctext" href="#Short-circuit-evaluation-1">Short-circuit evaluation</a></li><li><a class="toctext" href="#Ternary-operator-1">Ternary operator</a></li><li><a class="toctext" href="#Anonymous-functions-1">Anonymous functions</a></li><li><a class="toctext" href="#Array-comprehensions-1">Array comprehensions</a></li><li><a class="toctext" href="#Map,-filter-and-reduce-1">Map, filter and reduce</a></li><li><a class="toctext" href="#do-syntax-1"><code>do</code> syntax</a></li><li><a class="toctext" href="#Set-1">Set</a></li><li><a class="toctext" href="#Parametric-types-and-functions-1">Parametric types and functions</a></li><li><a class="toctext" href="#Macros-1">Macros</a></li><li><a class="toctext" href="#Multi-dimensional-Arrays-1">Multi-dimensional Arrays</a></li><li><a class="toctext" href="#Calling-C-and-Fortran-code-1">Calling C and Fortran code</a></li><li><a class="toctext" href="#Glossary-1">Glossary</a></li></ul></li><li><a class="toctext" href="chap20.html">Debugging</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="chap19.html">The goodies</a></li></ul><a class="edit-page" href="https://github.com/BenLauwens/ThinkJulia.jl/blob/master/docs/src/chap19.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>The goodies</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="The-goodies-1" href="#The-goodies-1">The goodies</a></h1><p>One of my goals for this book has been to teach you as little Julia as possible. When there were two ways to do something, I picked one and avoided mentioning the other. Or sometimes I put the second one into an exercise.</p><p>Now I want to go back for some of the good bits that got left behind. Julia provides a number of features that are not really necessary—you can write good code without them—but with them you can sometimes write code that’s more concise, readable or efficient, and sometimes all three.</p><p>Credit: this chapter is a synthesis of the corresponding parts in the offical Julia documentation: <a href="https://docs.julialang.org/en/stable/">https://docs.julialang.org/en/stable/</a></p><h2><a class="nav-anchor" id="Named-tuples-1" href="#Named-tuples-1">Named tuples</a></h2><p>The components of tuples can optionally be named, in which case a named tuple is constructed:</p><pre><code class="language-julia-repl">julia&gt; x = (a=1, b=1+1)
(a = 1, b = 2)
julia&gt; x.a
1</code></pre><p>Named tuples are very similar to tuples, except that fields can additionally be accessed by name using dot syntax.</p><h2><a class="nav-anchor" id="Keyword-arguments-1" href="#Keyword-arguments-1">Keyword arguments</a></h2><p>Some functions need a large number of arguments. Remembering how to call such functions can be difficult. <strong>Keyword arguments</strong> can make these complex interfaces easier to use and extend by allowing arguments to be identified by name instead of only by position.</p><p>Functions with keyword arguments are defined using a semicolon in the signature:</p><pre><code class="language-julia">function plot(x, y; style=&quot;solid&quot;, width=1, color=&quot;black&quot;)
    ###
end</code></pre><p>When the function is called, the semicolon is optional: one can either call <code>plot(x, y, width=2)</code> or <code>plot(x, y; width=2)</code>.</p><h2><a class="nav-anchor" id="Short-circuit-evaluation-1" href="#Short-circuit-evaluation-1">Short-circuit evaluation</a></h2><p>The operators <code>&amp;&amp;</code> and <code>||</code> do a <strong>short-circuit evaluation</strong>: in a series of boolean expressions connected by these operators, only the minimum number of expressions are evaluated as are necessary to determine the final boolean value of the entire chain.</p><p>For example, a recursive factorial routine could be defined like this:</p><pre><code class="language-julia">function fact(n::Int)
    n &gt;= 0 || error(&quot;n must be non-negative&quot;)
    n == 0 &amp;&amp; return 1
    n * fact(n-1)
end</code></pre><h2><a class="nav-anchor" id="Ternary-operator-1" href="#Ternary-operator-1">Ternary operator</a></h2><p>The so-called &quot;ternary operator&quot;, <code>?:</code>, is closely related to the <code>if-elseif-else</code> syntax, but is used where a conditional choice between single expression values is required, as opposed to conditional execution of longer blocks of code. It gets its name from being the only operator in most languages taking three operands:</p><pre><code class="language-julia">a ? b : c</code></pre><p>The expression <code>a</code>, before the <code>?</code>, is a condition expression, and the ternary operation evaluates the expression <code>b</code>, before the <code>:</code>, if the condition <code>a</code> is true or the expression <code>c</code>, after the <code>:</code>, if it is false.</p><p>A recursive factorial routine could also be defined like this:</p><pre><code class="language-julia">fact(n::Int) = n &lt; 0 ? error(&quot;n must be non-negative&quot;) : n == 0 ? 1 : n * fact(n-1)</code></pre><h2><a class="nav-anchor" id="Anonymous-functions-1" href="#Anonymous-functions-1">Anonymous functions</a></h2><p>Functions in Julia are first-class objects: they can be assigned to variables, and called using the standard function call syntax from the variable they have been assigned to. They can be used as arguments, and they can be returned as values. They can also be created anonymously, without being given a name, using either of these syntaxes:</p><pre><code class="language-julia-repl">julia&gt; x -&gt; x^2 + 2x - 1
#1 (generic function with 1 method)

julia&gt; function (x)
           x^2 + 2x - 1
       end
#3 (generic function with 1 method)</code></pre><p>This creates a function taking one argument <code>x</code> and returning the value of the polynomial <span>$x^2 + 2x - 1$</span> at that value. Notice that the result is a generic function, but with a compiler-generated name based on consecutive numbering.</p><p>The primary use for <strong>anonymous functions</strong> is passing them to functions which take other functions as arguments. See next sections.</p><h2><a class="nav-anchor" id="Array-comprehensions-1" href="#Array-comprehensions-1">Array comprehensions</a></h2><p>For example, this function takes an array of strings, maps the string function capitalize to the elements, and returns a new array of strings:</p><pre><code class="language-julia">function capitalizeall(t)
    res = []
    for s in t
        push!(res, uppercase(s))
    end
    res
end</code></pre><p>We can write this more concisely using an <strong>array comprehension</strong>:</p><pre><code class="language-julia">function capitalizeall(t)
    [uppercase(s) for s in t]
end</code></pre><p>The bracket operators indicate that we are constructing a new array. The expression inside the brackets specifies the elements of the array, and the for clause indicates what sequence we are traversing.</p><p>The syntax of an array comprehension is a little awkward because the loop variable, <code>s</code> in this example, appears in the expression before we get to the definition.</p><p>Array comprehensions are concise and easy to read, at least for simple expressions. And they are usually faster than the equivalent <code>for</code> loops, sometimes much faster. So if you are mad at me for not mentioning them earlier, I understand.</p><p>But, in my defense, array comprehensions are harder to debug because you can’t put a print statement inside the loop. I suggest that you use them only if the computation is simple enough that you are likely to get it right the first time. And for beginners that means never.</p><h2><a class="nav-anchor" id="Map,-filter-and-reduce-1" href="#Map,-filter-and-reduce-1">Map, filter and reduce</a></h2><p><code>capitalizeall</code> can also be written with the <code>map</code> function:</p><pre><code class="language-julia">function capitalizeall(word)
    map(uppercase, word)
end</code></pre><p><code>map(f, c...)</code> transforms collection c by applying f to each element.</p><p><code>reduce(op, itr)</code> reduces the given collection <code>itr</code> with the given binary operator <code>op</code>.</p><pre><code class="language-julia-repl">julia&gt; reduce(*, [2, 3, 4])
24</code></pre><p>Reductions for certain commonly-used operators have special implementations which should be used instead: <code>maximum(itr)</code>, <code>minimum(itr)</code>, <code>sum(itr)</code>, <code>prod(itr)</code>, <code>any(itr)</code>, <code>all(itr)</code>.</p><p>We could use <code>any</code> to rewrite some of the search functions we wrote in Section 9.3. For example, we could write <code>avoids</code> like this:</p><pre><code class="language-julia">function avoids(word, forbidden)
    !any(letter ∈ forbidden for letter in word)
end</code></pre><p>The function almost reads like English, “word avoids forbidden if there are not any forbidden letters in word.”</p><p><code>filter</code> can be used to filter a collection. For example, this function selects only the elements of <code>word</code> that are upper case, and returns a new string:</p><pre><code class="language-julia">function onlyupper(word)
    filter(letter-&gt;isuppercase(letter), word)
end</code></pre><p><code>filter(function, collection)</code> returns a copy of collection, removing elements for which function returns <code>false</code>. For associative collections, the function is passed two arguments (<code>key</code> and <code>value</code>).</p><h2><a class="nav-anchor" id="do-syntax-1" href="#do-syntax-1"><code>do</code> syntax</a></h2><p>Passing functions as arguments to other functions is a powerful technique, but the syntax for it is not always convenient. Such calls are especially awkward to write when the function argument requires multiple lines. As an example, consider calling <code>map</code> on a function with several cases:</p><pre><code class="language-julia">map(character-&gt;begin
           if isletter(character)
               return uppercase(character)
           elseif isnumeric(character)
               return character
           else
               return &#39;_&#39;
           end
       end,
    word)</code></pre><p>A block delimited by <code>begin</code> and <code>end</code> is used to implement the anonymous function.</p><p>Julia provides a reserved word <code>do</code> for rewriting this code more clearly:</p><pre><code class="language-julia">map(word) do character
    if isletter(character)
        return uppercase(character)
   elseif isnumeric(character)
        return character
    else
        return &#39;_&#39;
    end
end</code></pre><p>The <code>do character</code> syntax creates an anonymous function with argument <code>character</code> and passes it as the first argument to <code>map</code>.</p><p>How these arguments are initialized depends on the &quot;outer&quot; function; here, <code>map</code> will sequentially set <code>character</code> to the characters in <code>word</code>, calling the anonymous function on each.</p><p>This syntax makes it easier to use functions to effectively extend the language, since calls look like normal code blocks.</p><h2><a class="nav-anchor" id="Set-1" href="#Set-1">Set</a></h2><p>In Section 13.6 I use dictionaries to find the words that appear in a document but not in a word array. The function I wrote takes <code>d1</code>, which contains the words from the document as keys, and <code>d2</code>, which contains the array of words. It returns a dictionary that contains the keys from <code>d1</code> that are not in <code>d2</code>.</p><pre><code class="language-julia">function subtract(d1, d2)
    res = Dict()
    for key in keys(d1)
        if key ∉ keys(d2)
            res[key] = nothing
        end
    end
    res
end</code></pre><p>In all of these dictionaries, the values are <code>nothing</code> because we never use them. As a result, we waste some storage space.</p><p>Julia provides another built-in type, called a set, that behaves like a collection of dictionary keys with no values. Adding elements to a set is fast; so is checking membership. And sets provide functions and operators to compute common set operations.</p><p>For example, set subtraction is available as a function called <code>setdiff</code>. So we can rewrite <code>subtract</code> like this:</p><pre><code class="language-julia">function subtract(d1, d2)
    setdiff(d1, d2)
end</code></pre><p>The result is a set instead of a dictionary.</p><p>Some of the exercises in this book can be done concisely and efficiently with sets. For example, here is a solution to <code>hasduplicates</code>, from Exercise 10-7, that uses a dictionary:</p><pre><code class="language-julia">function hasduplicates(t)
    d = Dict()
    for x in t
        if x ∈ d
            return true
        end
        d[x] = nothing
    end
    false
end</code></pre><p>When an element appears for the first time, it is added to the dictionary. If the same element appears again, the function returns <code>true</code>.</p><p>Using sets, we can write the same function like this:</p><pre><code class="language-julia">function hasduplicates(t)
    length(Set(t)) &lt; length(t)
end</code></pre><p>An element can only appear in a set once, so if an element in <code>t</code> appears more than once, the set will be smaller than <code>t</code>. If there are no duplicates, the set will be the same size as <code>t</code>.</p><p>We can also use sets to do some of the exercises in Chapter 9. For example, here’s a version of <code>usesonly</code> with a loop:</p><pre><code class="language-julia">function usesonly(word, available)
    for letter in word
        if letter ∉ available
            return false
        end
    end
    true
end</code></pre><p><code>usesonly</code> checks whether all letters in <code>word</code> are in <code>available</code>. We can rewrite it like this:</p><pre><code class="language-julia">function usesonly(word, available)
    Set(word) ⊆ Set(available)
end</code></pre><p>The <code>⊆</code> operator checks whether one set is a subset or another, including the possibility that they are equal, which is true if all the letters in <code>word</code> appear in <code>available</code>.</p><p>As an exercise, rewrite <code>avoids</code> using sets.</p><h2><a class="nav-anchor" id="Parametric-types-and-functions-1" href="#Parametric-types-and-functions-1">Parametric types and functions</a></h2><p>An important and powerful feature of Julia&#39;s type system is that it is parametric: types can take parameters, so that type declarations actually introduce a whole family of new types – one for each possible combination of parameter values.</p><p>Type parameters are introduced immediately after the type name, surrounded by curly braces:</p><pre><code class="language-julia">struct MyPoint{T}
    x::T
    y::T
end</code></pre><p>This declaration defines a new <strong>parametric type</strong>, <code>MyPoint{T}</code>, holding two &quot;coordinates&quot; of type <code>T</code>. What, one may ask, is <code>T</code>? Well, that&#39;s precisely the point of parametric types: it can be any type at all. <code>MyPoint{Float64}</code> is a concrete type equivalent to the type defined by replacing <code>T</code> in the definition of <code>MyPoint</code> with <code>Float64</code>.</p><p>The type <code>MyPoint{Float64}</code> is a point whose coordinates are 64-bit floating-point values.</p><p><code>MyPoint</code> itself is also a valid type object, containing all instances as subtypes:</p><pre><code class="language-julia-repl">julia&gt; MyPoint{Float64} &lt;: MyPoint
true</code></pre><p>Method definitions can also have type parameters qualifying the signature:</p><pre><code class="language-julia">julia&gt; myappend(v::Array{T, 1}, x::T) where {T} = [v..., x]
myappend (generic function with 1 method)
julia&gt; print(myappend([1,2,3],4))
[1, 2, 3, 4]
julia&gt; myappend([1,2,3],2.5)
ERROR: MethodError: no method matching myappend(::Array{Int64,1}, ::Float64)</code></pre><p>As you can see, the type of the appended element must match the element type of the array it is appended to, or else a <code>MethodError</code> is raised.</p><h2><a class="nav-anchor" id="Macros-1" href="#Macros-1">Macros</a></h2><p>Macros provide a method to include generated code in the final body of a program. A macro maps a tuple of arguments to a returned expression, and the resulting expression is compiled directly rather than requiring a runtime <code>Core.eval</code> call. Macro arguments may include expressions, literal values, and symbols.</p><p>Here is an extraordinarily simple macro:</p><pre><code class="language-julia-repl">julia&gt; macro sayhello(name)
           return :( println(&quot;Hello, &quot;, $name) )
       end
@sayhello (macro with 1 method)</code></pre><p>Macros have a dedicated character in Julia&#39;s syntax: the <code>@</code> (at-sign). In this example, the compiler will replace all instances of <code>@sayhello(&quot;human&quot;)</code> with:</p><pre><code class="language-julia">:((println)(&quot;Hello, &quot;, &quot;human&quot;))</code></pre><p>When @sayhello is entered in the REPL, the expression executes immediately, thus we only see the evaluation result:</p><pre><code class="language-julia-repl">julia&gt; @sayhello &quot;human&quot;
Hello, human</code></pre><p>We can view the quoted return expression using the macro <code>@macroexpand</code>:</p><pre><code class="language-julia-repl">julia&gt; @macroexpand @sayhello &quot;human&quot;
:((println)(&quot;Hello, &quot;, &quot;human&quot;))</code></pre><p>We can see that the <code>&quot;human&quot;</code> literal has been interpolated into the expression.</p><p>Why do macros exist?</p><p>Macros are necessary because they execute when code is parsed, therefore, macros allow the programmer to generate and include fragments of customized code before the full program is run. To illustrate the difference, consider the following example:</p><pre><code class="language-julia-repl">julia&gt; macro twostep(arg)
           println(&quot;I execute at parse time. The argument is: &quot;, arg)
           return :(println(&quot;I execute at runtime. The argument is: &quot;, $arg))
       end
@twostep (macro with 1 method)

julia&gt; ex = @macroexpand @twostep 1, 2, 3
I execute at parse time. The argument is: (1, 2, 3)
I execute at runtime. The argument is: (1, 2, 3)</code></pre><p>The first call to <code>println</code> is executed when <code>macroexpand</code> is called. The resulting expression contains only the second <code>println</code>:</p><pre><code class="language-julia-repl">julia&gt; typeof(ex)
Expr

julia&gt; ex
I execute at runtime. The argument is: (1, 2, 3)

julia&gt; Core.eval(Main, ex)
I execute at runtime. The argument is: (1, 2, 3)</code></pre><p>Macros are invoked with the following general syntax:</p><pre><code class="language-julia">@name expr1 expr2 ...
@name(expr1, expr2, ...)</code></pre><p>Note the distinguishing <code>@</code> before the macro name and the lack of commas between the argument expressions in the first form, and the lack of whitespace after <code>@name</code> in the second form. The two styles should not be mixed.</p><h2><a class="nav-anchor" id="Multi-dimensional-Arrays-1" href="#Multi-dimensional-Arrays-1">Multi-dimensional Arrays</a></h2><p>Julia, like most technical computing languages, provides a first-class array implementation. Most technical computing languages pay a lot of attention to their array implementation at the expense of other containers. Julia does not treat arrays in any special way. The array library is implemented almost completely in Julia itself, and derives its performance from the compiler, just like any other code written in Julia.</p><h2><a class="nav-anchor" id="Calling-C-and-Fortran-code-1" href="#Calling-C-and-Fortran-code-1">Calling C and Fortran code</a></h2><p>Though most code can be written in Julia, there are many high-quality, mature libraries for numerical computing already written in C and Fortran. To allow easy use of this existing code, Julia makes it simple and efficient to call C and Fortran functions. Julia has a “no boilerplate” philosophy: functions can be called directly from Julia without any “glue” code, code generation, or compilation – even from the interactive prompt. This is accomplished just by making an appropriate call with <code>ccall</code> syntax, which looks like an ordinary function call.</p><p>In chapter 14 I introduced a Julia interface to the GDBM library of database functions. The library is written in C. To close the database a function call to <code>close(db)</code> has to be made:</p><pre><code class="language-julia">Base.close(dbm::DBM) = gdbm_close(dbm.handle)

function gdbm_close(handle::Ptr{Cvoid})
  ccall((:gdbm_close, &quot;libgdbm&quot;), Cvoid, (Ptr{Cvoid},), handle)
end</code></pre><p>A dbm object has a field <code>handle</code> of <code>Ptr{Cvoid}</code> type. This field holds a c pointer that refers to the database. To close the database the c function <code>gdbm_close</code> has to be called having as only argument the c pointer pointing to the database and no return value. Julia does this directly with the <code>ccall</code> function having as arguments:</p><ul><li>a tuple consisting of a symbol holding the name of the function we want to call: <code>:gdbm_close</code> and the shared library specified as a string: <code>&quot;libgdm&quot;</code>,</li><li>the return type: <code>Cvoid</code>,</li><li>a tuple of argument types: <code>(Ptr{Cvoid},)</code> and</li><li>the argument values: <code>handle</code>.</li></ul><p>The complete mapping of the GDBM library can be found as an example in the ThinkJulia sources.</p><h2><a class="nav-anchor" id="Glossary-1" href="#Glossary-1">Glossary</a></h2><p><em>keyword arguments</em>: arguments identified by name instead of only by position.</p><p><em>short-circuit evaluation</em>: Evalutation of boolean operator for which the second argument is executed or evaluated only if the first argument does not suffice to determine the value of the expression.</p><p><em>anonymous functions</em>:</p><p><em>array comprehension</em>:</p><p><em>parametric type</em>:</p><footer><hr/><a class="previous" href="chap18.html"><span class="direction">Previous</span><span class="title">Subtyping</span></a><a class="next" href="chap20.html"><span class="direction">Next</span><span class="title">Debugging</span></a></footer></article></body></html>
